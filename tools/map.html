<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wasteland Map Renderer</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            margin-bottom: 20px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #555;
        }
        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
        }
        button:hover { background-color: #45a049; }
        #status { margin-top: 10px; font-size: 0.9em; color: #aaa; }
        
        /* Container für die Map mit Scrollbars, falls der Screen zu klein ist */
        #canvas-container {
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: auto;
            max-width: 95vw;
            max-height: 80vh;
        }
        canvas {
            display: block;
            image-rendering: pixelated; /* Wichtig für scharfe Pixel-Grafik */
        }
    </style>
</head>
<body>

    <h1>Weltkarten Renderer (Stitching)</h1>
    
    <div class="controls">
        <button onclick="generateAndRender()">Welt neu generieren & Rendern</button>
        <button onclick="downloadMap()" style="background-color: #008CBA;">Als PNG speichern</button>
        <div id="status">Bereit.</div>
    </div>

    <div id="canvas-container">
        <canvas id="mapCanvas"></canvas>
    </div>

<script>
/**
 * KONFIGURATION
 */
const SECTORS_X = 10;
const SECTORS_Y = 10;
const TILE_COUNT = 50; // Tiles pro Sektor (Breite/Höhe)
const PIXEL_SIZE = 4;  // Wie groß ist ein Tile im Bild? (z.B. 4x4 Pixel)

// Berechnete Gesamtgröße
const TOTAL_TILES_WIDTH = SECTORS_X * TILE_COUNT;   // 500
const TOTAL_TILES_HEIGHT = SECTORS_Y * TILE_COUNT;  // 500

// Farben für die Symbole (Mapping)
const COLORS = {
    '.': '#8B4513', // Boden (Erde/Standard) - SaddleBrown
    '#': '#555555', // Ruine/Wand - DimGray
    't': '#228B22', // Baum - ForestGreen
    '^': '#A9A9A9', // Berg - DarkGray
    '~': '#1E90FF', // Wasser - DodgerBlue
    '=': '#333333', // Straße - DarkCharcoal
    '+': '#DEB887', // Brücke - BurlyWood
    'V': '#FFFF00', // Vault - Yellow
    'C': '#FF0000', // City - Red
    'default': '#000000'
};

// Biome Definitionen (für die Simulation)
const BIOMES = {
    FOREST: 'forest',
    SWAMP: 'swamp',
    MOUNTAIN: 'mountain',
    DESERT: 'desert',
    WASTELAND: 'wasteland'
};

/**
 * SIMULIERTE WORLD GEN LOGIK
 * (Dies ersetzt den Import von game_world_gen.js für dieses Standalone Tool)
 */
class MockWorldGen {
    
    static getBiome(sx, sy) {
        // Logik basierend auf deiner Tabelle
        if (sx <= 2 && sy <= 2) return BIOMES.FOREST;
        if (sx >= 7 && sy <= 2) return BIOMES.SWAMP;
        
        // Mountain Logic (Tabelle sagt y>=3 für x<=2, Code Korrektur sagte y>=7)
        // Wir nehmen hier die visuell interessantere Tabellen-Version für das Rendering
        if (sx <= 2 && sy >= 3) return BIOMES.MOUNTAIN; 
        
        if (sx >= 7 && sy >= 7) return BIOMES.DESERT;
        return BIOMES.WASTELAND;
    }

    static createSector(width, height, biome, sx, sy) {
        let sector = [];
        
        // Deterministischer Seed Simulator (einfach)
        // Damit Sektor 4,4 immer gleich aussieht
        const seedBase = (sx * 100) + sy;

        for (let y = 0; y < height; y++) {
            let row = [];
            for (let x = 0; x < width; x++) {
                // Pseudo-Zufall basierend auf Position
                const rand = Math.sin(seedBase + x * 12.9898 + y * 78.233) * 43758.5453;
                const r = rand - Math.floor(rand); // 0.0 bis 1.0

                let tile = '.'; // Standard Boden

                // Vault Eingang fest bei 4,4 in der Mitte
                if (sx === 4 && sy === 4 && x === 25 && y === 25) {
                    tile = 'V';
                } else {
                    // Biome spezifische Generierung
                    switch (biome) {
                        case BIOMES.FOREST:
                            if (r > 0.6) tile = 't'; // Viel Wald
                            if (r < 0.02) tile = '~'; // Kleine Teiche
                            break;
                        case BIOMES.SWAMP:
                            if (r > 0.7) tile = '~'; // Viel Wasser
                            if (r > 0.5 && r <= 0.7) tile = 't';
                            break;
                        case BIOMES.MOUNTAIN:
                            if (r > 0.6) tile = '^'; // Felsen
                            break;
                        case BIOMES.DESERT:
                            if (r > 0.95) tile = '^'; // Vereinzelte Felsen
                            if (r < 0.05) tile = '#'; // Ruinen im Sand
                            break;
                        case BIOMES.WASTELAND:
                            if (r > 0.90) tile = '#'; // Ruinen
                            if (r > 0.85 && r <= 0.90) tile = '='; // Straßenreste (simuliert)
                            break;
                    }
                }
                row.push(tile);
            }
            sector.push(row);
        }
        return sector;
    }
}

/**
 * RENDERING LOGIK
 */
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');

function initCanvas() {
    // Canvas Größe setzen
    canvas.width = TOTAL_TILES_WIDTH * PIXEL_SIZE;   // 2000px
    canvas.height = TOTAL_TILES_HEIGHT * PIXEL_SIZE; // 2000px
    
    // Hintergrund schwarz
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawTile(globalX, globalY, char) {
    const color = COLORS[char] || COLORS['default'];
    ctx.fillStyle = color;
    
    // Position berechnen
    const px = globalX * PIXEL_SIZE;
    const py = globalY * PIXEL_SIZE;
    
    ctx.fillRect(px, py, PIXEL_SIZE, PIXEL_SIZE);
}

async function generateAndRender() {
    statusDiv.textContent = "Generiere Welt...";
    statusDiv.style.color = "yellow";
    
    // Kleiner Timeout, damit der UI-Text sich updated bevor der Heavy-Process startet
    setTimeout(() => {
        initCanvas();
        
        let totalTiles = 0;

        // 1. Loop über Sektoren (Y)
        for (let sy = 0; sy < SECTORS_Y; sy++) {
            // 2. Loop über Sektoren (X)
            for (let sx = 0; sx < SECTORS_X; sx++) {
                
                // Welches Biom?
                const biome = MockWorldGen.getBiome(sx, sy);
                
                // Sektor generieren (2D Array)
                const sectorMap = MockWorldGen.createSector(TILE_COUNT, TILE_COUNT, biome, sx, sy);
                
                // 3. Loop über Tiles im Sektor (Y)
                for (let ly = 0; ly < TILE_COUNT; ly++) {
                    // 4. Loop über Tiles im Sektor (X)
                    for (let lx = 0; lx < TILE_COUNT; lx++) {
                        
                        const tileChar = sectorMap[ly][lx];
                        
                        // Absolute Koordinate berechnen
                        // GlobalX = (SektorX * 50) + LocalX
                        const globalX = (sx * TILE_COUNT) + lx;
                        const globalY = (sy * TILE_COUNT) + ly;
                        
                        drawTile(globalX, globalY, tileChar);
                        totalTiles++;
                    }
                }
            }
        }
        
        // Grid-Linien über Sektoren zeichnen (optional, zur Orientierung)
        drawGridOverlay();

        statusDiv.textContent = `Fertig! ${totalTiles} Tiles gerendert. Größe: ${canvas.width}x${canvas.height}px`;
        statusDiv.style.color = "#4CAF50";
    }, 100);
}

function drawGridOverlay() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; // Sehr transparentes Weiß
    ctx.lineWidth = 2;

    // Vertikale Sektor-Linien
    for (let i = 0; i <= SECTORS_X; i++) {
        ctx.beginPath();
        ctx.moveTo(i * TILE_COUNT * PIXEL_SIZE, 0);
        ctx.lineTo(i * TILE_COUNT * PIXEL_SIZE, canvas.height);
        ctx.stroke();
    }

    // Horizontale Sektor-Linien
    for (let i = 0; i <= SECTORS_Y; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * TILE_COUNT * PIXEL_SIZE);
        ctx.lineTo(canvas.width, i * TILE_COUNT * PIXEL_SIZE);
        ctx.stroke();
    }
}

function downloadMap() {
    const link = document.createElement('a');
    link.download = 'wasteland_world_map.png';
    link.href = canvas.toDataURL();
    link.click();
}

// Start beim Laden
window.onload = initCanvas;

</script>
</body>
</html>
